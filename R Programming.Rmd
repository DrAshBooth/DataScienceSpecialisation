---
title: "R Programming"
output: html_document
---

This document contains information and code from the Coursera "R Programming" course.

# Week 1
The first week focuses on getting started and R's nuts and bolts, including: data types reading data, connections, subsetting and vectorised operations.

## Classes
Notes from the class videos

### Creating vectors
```{r}
x <- c(1,1,1)
y <- vector("numeric", length=3)
x
y
```

### Explicit Coercion
```{r}
x <- 0:5
class(x)
as.numeric(x)
as.logical(x)
as.character(x)
```

In some cases coercion does not make sense:
```{r}
x <- c("a","b","c")
as.numeric(x)
as.logical(x)
```

### Lists
Lists are a special type of vector that can contain elements of different classes.
```{r}
x <- list(1,"a",TRUE,1+4i)
x
```

### Matrices
Matrices are vectors with a dimension attribute. The dimension attribute is itself and integer vector of length 2 (nrow,ncol).
```{r}
m <- matrix(nrow=2,ncol=3)
m
dim(m)
```

Matrices are constructed column-wise, e.g.:
```{r}
m <- matrix(1:6, nrow=2,ncol=3)
m
```

Matrices may even be created directly from a vector by adding a dimension attribute, e.g.:
```{r}
m <- 1:10
m
dim(m) <- c(2,5)
m
```

# cbind-ing and rbind-ing
Matrices can be created by column-binding or row-binding with ```cbind()``` and ```rbind()```:
```{r}
x <-1:3
y <- 10:12
cbind(x,y)
rbind(x,y)
```

### Factors
Factors are used to represent categorical data. They can be unordered or ordered. You can think of a factor as an integer vector where each integer has a label.

* Factors are treated specially by modelling functions like ```lm()``` and ```gm()```.
* Using factors with labels is better than using integers because factors are self-describing; having a variable that has values "Male" and "Female" is better than a variable that has values 1 and 2.

```{r}
x <- factor(c("yes", "yes", "no", "yes", "no"))
x
table(x)
unclass(x)
```

The order of the levels can be set using the ```levels``` argument to ```factor()```. This can be important in linear modelling because the first level is used as the baseline level.

```{r}
x <- factor(c("yes", "yes", "no", "yes", "no"),
            levels=c("yes","no"))
x
```

### Missing values

Missing values are denoted by either NA or NaN for undefined mathematical operations.

You can check for NA using ```is.na()```:

```{r}
x <- c(1, 2, NA, 4, 5)
is.na(x)
```

### Data Frames

Data frames are used to store tabular data

* They are represented as a special type of list where every element of the list has to have the same length
* Each element of the list can be thought of as a column and the length of each element of the list is the number of rows.
* Unlike matrices, data frames can store different classes of objects in each column (just like lists).
* Data frames also have a special attribute called row.names
* Data frames are usually created by calling ```read.table()``` or ```read.csv()```.
* Can be converted to a matrix by calling ```data.matrix()```.

Besides the above, we can also use the ```data.frame()``` function to create them:
```{r}
x <- data.frame(foo = 1:4, bar = c(T,T,F,F))
x
nrow(x)
```

### Names
All R objects (not just data frames) can have names. This is very useful for writing readable code and self-describing objects.

```{r}
x <- 1:3
names(x) <- c("foo", "bar", "norf")
x
names(x)
```

List can also be named:
```{r}
x <- list(a=1,b=2,c=3)
x
```

as can matrices...
```{r}
m <- matrix(1:4,nrow=2,ncol=2)
dimnames(m) <- list(c("a","b"),c("d","e"))
m
```

### Reading large tables

With relatively large data sets, there are a few "tricks" that can make your life easier and prevent R from chocking when reading data:

* Make a rough calculation of the memory required to store your data set. If the data set is larger than the amount of RAM on your computer then you can probably stop there.
* Set ```comment.char=""``` if there are no commented lines in your file.
* Use the ```colClasses``` argument. Specifying this option instead of using the default can make ```read.table()``` run MUCH faster, often twice as fast. In order 
* Set ```nrows```. This doesn't make R run faster but it helps with memory usage. A mild overestimate is okay. You can use the Unix tool ```wc``` to calculate the number of lines in a file.

### Textual formats

* **Dumping** and **dputing** are useful because the resulting textual format is edit-able, and in the case of corruption, potentially recoverable.
* Unlike writing out a table or csv file, ```dump``` and ```dput``` preserve the metadata (sacrificing some readability) so that another user doesn't have to specify it all over again.
* Textual formats can work much better with version control programs.
* They can be longer lived; if there is corruption somewhere in the file, it can be easier to fix the problem.
* Textual formats adhere to the "Unix philosophy".
* Downside: The format is not very space=efficient.

You can deparse an R object with ```dput``` and read it back in with ```dget```:
```
y <- data.frame(a=1,b="a")
dput(y, "file.R")
new.y <- dget("y.R")
```

Multiple r objects can be deparsed using the dump function and read back in using source.
```
x <- "foo"
y <- data.frame(a=1,b="a")
dump(c("x","y"), "file.R")
rm(x,y)
source("file.R")
```

### Connections: Interfaces to the outside world
Data are read in using connection interfaces. Connections can be made to files or to other more exotic things.

* ```file```, opens a connection to a file.
* ```gzfile```, opens a connection to a file compressed with gzip.
* ```bzfile```, opens a connections to a file compressed with bzip2.
* ```url```, opens a connection to a webpage.

In general, connections are powerful tools that let you navigate files or other external objects. In conjunction with the readlines function, connections may be used to read webpages:

```{r}
con <- url("http://www.jhsph.edu", "r")
x <- readLines(con)
head(x)
```

### Subsetting: Basics

There are a number of operators that can be used to extract subsets of R objects:

* ```[``` always returns an object of the same class as the original; can be used to select more than one element.
* ```[[``` is used to extract elements of a list or data frame; it can only be used to extract a single element and the class of the returned object will not necessarily be a list or data frame.
* ```$``` is used to extract elements of a list or data frame by name; semantics are similar to that of ```[[```.

### Subsetting: Vectors

```{r}
x <- c("a", "b", "c", "d", "a")
x[1]
x[1:3]
x[x>"a"]
```

### Subsetting: Lists

Lists may be subsetted by any of the three methods discussed about but each will provide a different result. 

```{r}
x <- list(foo=1:4, bar=0.6)
x[1]
x[[1]]
x$bar
x[["bar"]]
x["bar"]
```

To extract multiple elements from a list, you must use the single bracket operator:

```{r}
x <- list(foo=1:4, bar=0.6, baz = "hello")
x[c(1,3)]
```

The nice thing about the double bracket operator is that it can be used with computed indices; ```$``` can only be used with literal names:

```{r}
x <- list(foo=1:4, bar=0.6, baz = "hello")
name <- "foo"
x[[name]]
x$name
```

### Subsetting: Nested elements of a list

```{r}
x <- list(a=list(10,12,14), b=c(3.14,2.81))
x[[c(1,3)]]
x[[1]][[3]]
```

### Subsetting: Matrices

Matrices may be subsetted in the usual way with (i,j) type indices, as well ass missing indices:

```{r}
x <- matrix(1:6,2,3)
x[1,2]
x[1,]
x[,2]
```

By default, when a single element of a matrix is retrieved, it is returned as a vector of length 1 rather than a 1 x 1 matrix. This behavior can be turned off by setting ```drop=FALSE```.

### Subsetting: Removing missing values

A common task is the removal of missing values.

```{r}
x <- c(1,2,NA,4,NA,6)
bad <- is.na(x)
x[!bad]
```

If there are multiple things from which you want to create a subset with no missing values, then ```complete.cases()``` is your man:

```{r}
x <- c(1,2,NA,4,NA,6)
y <- c("a","b",NA,NA,"e","f")
good<-complete.cases(x,y)
x[good]
y[good]
```

Complete cases can also be used to remove missing values from data frames in the same manner.

### Vectorised operations

Many operations in R are vectorized making code more efficient, concise and easier to read.

```{r}
x <- 1:4; y <- 6:9
x+y
x>2
```

### Vectorised matrix operations

Element wise multiplication:
```{r}
x <- matrix(1:4,2,2); y <- matrix(rep(10,4),2,2)
x*y
```

True matrix multiplication:
Element wise multiplication:
```{r}
x <- matrix(1:4,2,2); y <- matrix(rep(10,4),2,2)
x%*%y
```

# Week 1
The second week jumps into programming with R.

## Classes
Notes from the class videos

### Control structures - If-else
Allows you to test logical conditions and let R do things based on whether of not that condition is true.
```
if(<condition>) {
  # do something
} else {
  # do something else
}

if(<condition1>) {
  # do something
} else if(<condition2> {
  # do something different
} else {
  # do something else
}
```
### Control structures - For Loop
for loops take an iterator variable and assign it successive values from a sequence or vector. For loops are most commonly used for iteration over the elements of an object:
```
for(i in 1:10) {
  print(i)
}
```

for loops can also be nested but things can get hard to read very quickly:
```
x<- matrix(1:6,2,3)
for(i in seq_len(nrow(x))) {
  for(j in seq_len(ncol(x))) {
    print[x[i,j]]
  }
}
```

### Control structures - While Loop
While loops begin by testing a condition. If it is true, then they execute the loop body. Once the loop body is executed, the condition is tested again.
```
count <- 0
while(count<10) {
  print(count)
  count<-count+1
}
```

If not written with care, while loops may result in infinite loops. There can be more than one condition in the test, where conditions are evaluated from left to right:
```
z <- 5
while(z >= 3 && z <=10) {
  print(z)
  coin <- rbinom(1, 1, 0.5)
  
  if(coin == 1) { ## random walk
    z <- z+1
  } else {
    z <- z-1
  }
}
```

### Control structures - Repeat
Repeat is a construct that initiates and infinite loop; these are not commonly used in statistical applications but they do have their uses. The only way to exit a repeat loop is to call ```break```
```
x0 <- 1
tol <-1e-8

repeat {
  x1 <- computeEstimate()
  
  if (abs(x1-x0) < tol) {
    break
  } else {
    x0 <- x1
  }
}
```

Repeat loops can be dangerous when there is no guarantee that they will stop. It is usually better to set a hard number of iterations (e.g. using a for loop) and then report whether convergence was achieved or not.

### Control structures - Next
```next``` is used to skip an iteration of a loop
```
for(i in 1:100) {
  if(i <=20) {
    ## skip the first 20 iterations
    next
  }
  ### Do something here
}
```

### Writing functions in R
In R, the function returns whatever the last expression was.
```
aboveX <- function(x, threshold) {
  use <- x>threshold
  x[use]
}
```

R functions also allow default arguments, as below:
```
aboveX <- function(x, threshold=10) {
  use <- x>threshold
  x[use]
}
```

Most function will revolve around data structures and the following code creates a function calculates the mean of each column in a dataframe or matrix.
```
columnMean <- function(y, removeNA = TRUE) {
  nc <- ncol(y)
  means <- numeric(nc)
  for(i in 1:nc) {
    means[i] <- mean(y[,i],na.rm=removeNA)
  }
  means
}
```

### Arguement Matching
R function arguments can be matched positionally or by name. So the following calls to sd are all equivalent:
```
sd(mydata)
sd(x=mydata)
sd(x=mydata, na.rm=FALSE)
sd(na.rm=FALSE, x=mydata)
sd(na.rm=FALSE, mydata)
```

Even though it is legal, I don't recommend messing around with the order of the arguments too much, it can lead to considerable confusion.

You can mix positional matching with matching by name. When an argument is matched by name, it is "taken out" of the argument list and the remaining unnamed arguments are matched in the order that they are listed in the function definition.
```{r}
args(lm)
```

### Lazy Evaluation
Arguments to functions are evaluated lazily, so they are evaluated only as needed.
```
f <- function(a,b) {
 a^2
}
f(2)
```

This function never actually uses the argument ```b```, so calling ```f(2)``` will not produce an error because the 2 gets possitionally matched to ```a```.

### The "..." Argument
The ```...``` argument indicates a variable number of arguments that are usually passed on to other functions.

* ```...``` is often used when extending another function and you don't want to copy the entire argument list of the original function.
```
myplot <-function(x, y, type="l", ...) {
  plot(x, y, type=type, ...)
}
```
* Generic functions use ```...``` so that extra arguments can be passed to methods (more on this later).
```{r}
mean
```

The ```...``` argument is also necessary when the number of arguments passed to the function cannot be known in advance
```{r}
args(paste)
```

One catch with the ```...``` argument is that any arguments that appear after it on the argument list must be names explicitly and cannot be partially matched.

### Symbol binding
When R tries to bind a value to a symbol, it searches through a series of ```environments``` to find the appropriate value. When you are working on the command line and need to retrieve the value of an R object, the order is roughly:

1. Search the global environment for a symbol name matching the one requested.
2. Search the namespaces of each of the packages n the searchlist.

The searchlist can be found using the ```search``` function:
```{r}
search()
```
 * The global environement or the user's workspace is always the first elemenet of the search list and the base package is always the last.
 * The order of the packages on the search list matters
 * User's can configure which packages get loaded on startup so you cannot assume that there will be a set list of packages available.
 * When a user loads a package with ```library``` the namespace of that package gets put in position 2 of the search list.
 * Note that R has separate namespaces for functions and non-functions so it's possible to have an object named c and a fucntion names c.

### Scoping rules
The scoping rules for R are the main feature that make it sifferent from the original S language.

* The scoping rules determine how a value is associated with a free variable in a function
* R uses lexical scoping or static scoping. A common alternative is dynamic scoping.
* Related to the scoping rules is how R uses the search list to bind a value to a symbol.
* Lexical scoping turns out to be particularly useful for simplifying statistical computations.

Consider the following function:
```
f <- function(x, y) {
  x^2 + y / z
}
```

This function has two formal arguments x and y. In the body of the function there is another symbol ```z```. In this case ```z``` is called a free variable. The scoping rules of the language determine how values are assigned to the free variables. Free variables are not formal arguments and are not local variables.

### Lexical scoping
Lexical scoping means that:

> the values of free variables are searched for in the environment in which the function was defined.

What is an environment?

* A collection of (symbol, value) pairs, i.e. x is a symbol and 3.14 might be its value.
* Every environment has a parent environment; it is possible for an environment to have multiple "children".
* The only environment without a parent is the empty environment.
* A function + an environment = a closure or function closure.

So what hapens when searching for the value for a free variable:

* If the value of a symbol is not found in the environment in which a function was defined, then the search is continued in the parent environment.
* The search environment continues down the sequence of parent environments until we hit the top-level environement; this is usually the global environment or the namespace of a package.
* After the top-level environment, the search continues down the search list until we hit the empty environment. If the value for a gien symbol cannot be found by this point then and error is thrown.

Why does all of this matter?

* Typicaly, a function is defined in the global environment, so that the values of the free variables are just found in the user's workspace.
* This behaviour is logical for most people and is usually the "right thing" to do.
* However, in R you can have functions defined inside other functions
  ** Languages like C don't let you do this
* Now things get interesting - In this case the environment in which the function is defined is the body of another function!

```{r}
make.power <- function(n) {
  pow <- function(x) {
    x^n
  }
  pow
}
```

This function returns another function as its value.

```{r}
cube <-make.power(3)
square <- make.power(2)
cube(3)
square(3)
```

### Exploring a function closure
What's in a function's environment?
```{r}
ls(environment(cube))
get("n", environment(cube))
```

### Consequences of Lexical Scoping

* In R, all objects must be stored in memory
* All functions must carry a pointer to their respective defining environments, which could be anywhere.
* In S-PLUS, free variables are always looked up in the global workspace, so everything can be stored on the disk because the defining environment of all the functions are the same.

### Coding Standards for R

1. Always use text files / text editor
2. Indent your code
3. Limit the width of your code (80 columns?)
4. Limit the length of individual functions

### Indenting

* Indenting improves readability
* Fixing line length (80 columns) prevents lots of nesting and very long functions
* Suggested: Indents of 4 spaces at minimum; 8 spaces ideal

### Dates and Times in R
R has developed a special representation of dates and times

* Dates are represented by the Date class
* Times are represented by the POSIXct or the POSIXlt class
* Dates are stored internally as the number of days since 1970-01-01
* Tmes are stored internally as the number of seconds since 1970-01-01

### Dates in R
Dates are represented by the Date class and can be coerced from a character string using the ```as.Date()``` function.
```{r}
x <- as.Date("1970-01-01")
x
unclass(x)
unclass(as.Date("1970-01-02"))
```

### Times in R
Times are represented using the POSIXct or the POSIXlt class

* POSIXct is just a very large integer under the hood; it use a useful class when you want to store times in something like a data frame.
* POSIXlt is a list underneath and it stores a bunch of other useful information like the day of the week, day of the year, month, day of the month

There are a number of generic functions that work on dates and times

* weekdays: give the day of the week
* months: give the month name
* quarters: give the quarter number (“Q1”, “Q2”, “Q3”, or “Q4”)

Times can be coerced from a character string using the ```as.POSIXlt``` or ```as.POSIXct``` function.
```{r}
x <- Sys.time()
x
p <- as.POSIXlt(x)
names(unclass(p))
p$sec
```

You can also use the POSIXct format.
```{r}
x <- Sys.time()
x  ## Already in ‘POSIXct’ format
p <- as.POSIXlt(x)
p$sec
```

Finally, there is the strptime function in case your dates are written in a different format
```{r}
datestring <- "January 10, 2012 10:40"
x <- strptime(datestring, "%B %d, %Y %H:%M")
x
class(x)
```

I can never remember the formatting strings. Check ?strptime for details.

### Operations on Dates and Times
You can use mathematical operations on dates and times. Well, really just + and -. You can do comparisons too (i.e. ==, <=)
```{r}
x <- as.Date("2012-01-01")
y <- strptime("9 Jan 2011 11:34:21", "%d %b %Y %H:%M:%S") 
x <- as.POSIXlt(x) 
x-y
```

Even keeps track of leap years, leap seconds, daylight savings, and time zones.
```{r}
x <- as.Date("2012-03-01") 
y <- as.Date("2012-02-28") 
x-y
x <- as.POSIXct("2012-10-25 01:00:00")
y <- as.POSIXct("2012-10-25 06:00:00", tz = "GMT") 
y-x
```

### Summary

* Dates and times have special classes in R that allow for numerical and statistical calculations
* Dates use the Date class
* Times use the POSIXct and POSIXlt class
* Character strings can be coerced to Date/Time classes using the strptime function or the ```as.Date```, ```as.POSIXlt```, or ```as.POSIXct```.

## Quiz - wk2

### Question 1
Suppose I define the following function in R:
```{r}
cube <- function(x, n) {
        x^3
}
```

What is the result of running in R after defining this function?
```{r}
cube(3)
```

### Question 2
The following code will produce a warning in R.
```{r}
x <- 1:10
if(x > 5) {
        x <- 0
}
```
Why?

### Question 3
Consider the following function:
```{r}
f <- function(x) {
        g <- function(y) {
                y + z
        }
        z <- 4
        x + g(x)
}
```

If I then run the below in R, what value is returned?
```{r}
z <- 10
f(3)
```

### Question 4
Consider the following expression:
```{r}
x <- 5
y <- if(x < 3) {
        NA
} else {
        10
}
```
What is the value of 'y' after evaluating this expression?
```{r}
y
```

### Question 5
Consider the following R function
```
h <- function(x, y = NULL, d = 3L) {
        z <- cbind(x, d)
        if(!is.null(y))
                z <- z + y
        else
                z <- z + f
        g <- x + y / z
        if(d == 3L)
                return(g)
        g <- g + 10
        g
}
```
Which symbol in the above function is a free variable?

### Question 6
What is an environment in R?

* a special type of function
* an R package that only contains data
* a collection of symbol/value pairs
* a list whose elements are all functions

### Question 7
The R language uses what type of scoping rule for resolving free variables?

* lexical scoping
* compilation scoping
* dynamic scoping
* global scoping

### Question 8
How are free variables in R functions resolved?

* The values of free variables are searched for in the global environment
* The values of free variables are searched for in the environment in which the function was called
* The values of free variables are searched for in the working directory
* The values of free variables are searched for in the environment in which the function was defined

### Question 9
What is one of the consequences of the scoping rules used in R?

* All objects can be stored on the disk
* R objects cannot be larger than 100 MB
* All objects must be stored in memory
* Functions cannot be nested

## Assignment 1 - wk2 - Air Pollution
For this first programming assignment you will write three functions that are meant to interact with dataset that accompanies this assignment. The dataset is contained in a zip file specdata.zip that can be downloaded here:

https://d396qusza40orc.cloudfront.net/rprog%2Fdata%2Fspecdata.zip

The zip file contains 332 comma-separated-value (CSV) files containing pollution monitoring data for fine particulate matter (PM) air pollution at 332 locations in the United States. Each file contains data from a single monitor and the ID number for each monitor is contained in the file name. For example, data for monitor 200 is contained in the file "200.csv". Each file contains three variables:

* Date: the date of the observation in YYYY-MM-DD format (year-month-day)
* sulfate: the level of sulfate PM in the air on that date (measured in micrograms per cubic meter)
* nitrate: the level of nitrate PM in the air on that date (measured in micrograms per cubic meter)

For this programming assignment you will need to unzip this file and create the directory 'specdata'. Once you have unzipped the zip file, do not make any modifications to the files in the 'specdata' directory. In each file you'll notice that there are many days where either sulfate or nitrate (or both) are missing (coded as NA). This is common with air pollution monitoring data in the United States.

### Part 1
Write a function named 'pollutantmean' that calculates the mean of a pollutant (sulfate or nitrate) across a specified list of monitors. The function 'pollutantmean' takes three arguments: 'directory', 'pollutant', and 'id'. Given a vector monitor ID numbers, 'pollutantmean' reads that monitors' particulate matter data from the directory specified in the 'directory' argument and returns the mean of the pollutant across all of the monitors, ignoring any missing values coded as NA.
```{r}
pollutantmean <- function(directory, pollutant, id = 1:332) {
  
  sumtotal <- 0
  n <- 0
  for( i in id) {
    # read in data
    fileName <- if(i<10) {
      paste(0,0,i,".csv",sep="")
    } else if(i<100) {
      paste(0,i,".csv", sep="")
    } else {
      paste(i,".csv", sep="")
    }
    data <- read.csv(paste("./",directory,"/",fileName,sep=""))
    sumtotal <- sumtotal + sum(data[[pollutant]], na.rm = T)
    n <- n + length(data[[pollutant]][complete.cases(data[[pollutant]])])
  }
  sumtotal/n
}
```

### Part 2
Write a function that reads a directory full of files and reports the number of completely observed cases in each data file. The function should return a data frame where the first column is the name of the file and the second column is the number of complete cases.
```{r}
complete <- function(directory, id = 1:332) {
  
  ns <- numeric(length(id))
  numObs <- numeric(length(id))
  
  counter <- 1
  for(i in id) {
   
    # read in data
    fileName <- if(i<10) {
      paste(0,0,i,".csv",sep="")
    } else if(i<100) {
      paste(0,i,".csv", sep="")
    } else {
      paste(i,".csv", sep="")
    }
    data <- read.csv(paste("./",directory,"/",fileName,sep=""))
    
    ns[counter] <- i
    numObs[counter] <- nrow(data[complete.cases(data),])
    
    counter <- counter + 1
  }
  x<-data.frame(ns,numObs)
  colnames(x) <- c("id","nobs")
  x
}
```

### Part 3
Write a function that takes a directory of data files and a threshold for complete cases and calculates the correlation between sulfate and nitrate for monitor locations where the number of completely observed cases (on all variables) is greater than the threshold. The function should return a vector of correlations for the monitors that meet the threshold requirement. If no monitors meet the threshold requirement, then the function should return a numeric vector of length 0.
```{r}
corr <- function(directory, threshold=0) {
  
  cors <- numeric()
  
  counter <- 1
  for(i in list.files("specdata")) {
    
    data <- read.csv(paste("./",directory,"/",i,sep=""))
    completeData <- data[complete.cases(data),]
    
    if(nrow(completeData) >= threshold) {
      cors[counter] <- cor(completeData$sulfate,completeData$nitrate)
      counter <- counter + 1
    }
  }
  cors
}

```

# Week 3 - Loop Functions and Debugging
This week is what I call "loop functions" in R, which are functions that allow you to execute loop-like behavior in a compact form. These functions typically have the word "apply" in them and are particularly convenient when you need to execute a loop on the command line when using R interactively. These functions are some of the more interesting functions of the R language. This week we also cover the debugger that comes with R and how to interpret its output to help you find problems in your programs and functions. The lecture videos for this week are:

* Loop functions: lapply apply tapply split mapply
* Debugger: Part 1 Part 2 Part 3

### Learning Objectives
By the end of this week you should be able to:

* Define an anonymous function and describe its use in loop functions [see lapply]
* Describe how to start the R debugger for an arbitrary R function
* Describe what the traceback() function does and what is the function call stack


## Classes
### Looping on the Command Line
Writing for, while loops is useful when programming but not particularly easy when working interactively on the command line. There are some functions which implement looping to make life easier.

* lapply: Loop over a list and evaluate a function on each element

* sapply: Same as lapply but try to simplify the result

* apply: Apply a function over the margins of an array

* tapply: Apply a function over subsets of a vector

* mapply: Multivariate version of lapply

An auxiliary function split is also useful, particularly in conjunction with lapply.

### lapply
lapply takes three arguments: (1) a list X; (2) a function (or the name of a function) FUN; (3) other arguments via its ... argument. If X is not a list, it will be coerced to a list using as.list.
```{r}
lapply
```
The actual looping is done internally in C code.

lapply always returns a list, regardless of the class of the input.
```{r}
x <- list(a = 1:5, b = rnorm(10))
lapply(x, mean)
```

```{r}
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
```

```{r} 
x <- 1:4
lapply(x, runif, min = 0, max = 10)
```

lapply and friends make heavy use of anonymous functions.
```{r}
x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2)) 
lapply(x, function(elt) elt[,1])
```

### sapply
sapply will try to simplify the result of lapply if possible.

* If the result is a list where every element is length 1, then a vector is returned

* If the result is a list where every element is a vector of the same length (> 1), a matrix is returned.

* If it can’t figure things out, a list is returned

```{r}
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
sapply(x, mean)
```

### apply
apply is used to a evaluate a function (often an anonymous one) over the margins of an array.

* It is most often used to apply a function to the rows or columns of a matrix

* It can be used with general arrays, e.g. taking the average of an array of matrices

* It is not really faster than writing a loop, but it works in one line!

```{r}
str(apply)
```

* X is an array
* MARGIN is an integer vector indicating which margins should be “retained”.
* FUN is a function to be applied
* ... is for other arguments to be passed to FUN

```{r}
x <- matrix(rnorm(200), 20, 10)
apply(x, 2, mean)
apply(x, 1, sum)
```

### col/row sums and means
For sums and means of matrix dimensions, we have some shortcuts.

* rowSums = apply(x, 1, sum)
* rowMeans = apply(x, 1, mean)
* colSums = apply(x, 2, sum)
* colMeans = apply(x, 2, mean)

The shortcut functions are much faster, but you won’t notice unless you’re using a large matrix.

Quantiles of the rows of a matrix:
```{r}
x <- matrix(rnorm(200), 20, 10)
apply(x, 1, quantile, probs = c(0.25, 0.75))
```

Average matrix in an array
```{r}
a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
apply(a, c(1, 2), mean)
```

### mapply
mapply is a multivariate apply of sorts which applies a function in parallel over a set of arguments.
```{r}
str(mapply)
function (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE,
          USE.NAMES = TRUE)
```

* FUN is a function to apply
* ... contains arguments to apply over
* MoreArgs is a list of other arguments to FUN.
* SIMPLIFY indicates whether the result should be simplified

The following is tedious to type
```
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1))
```

Instead we can do:
```{r}
mapply(rep, 1:4, 4:1)
```

### Vectorizing a Function
```{r}
noise <- function(n, mean, sd) {
  rnorm(n, mean, sd)
  }
noise(5, 1, 2)
mapply(noise, 1:5, 1:5, 2)
```

Which is the same as
```
list(noise(1, 1, 2), noise(2, 2, 2),
     noise(3, 3, 2), noise(4, 4, 2),
     noise(5, 5, 2))
```

### tapply
tapply is used to apply a function over subsets of a vector. I don’t know why it’s called tapply
```{r}
> str(tapply)
```

* X is a vector
* INDEX is a factor or a list of factors (or else they are coerced to factors)
* FUN is a function to be applied
* ... contains other arguments to be passed FUN
* simplify, should we simplify the result?

Take group means.
```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
f
tapply(x, f, mean)
```

Find group ranges.
```{r}
tapply(x, f, range)
```

### split
split takes a vector or other objects and splits it into groups determined by a factor or list of factors.
```{r}
str(split)
```

* x is a vector (or list) or data frame
* f is a factor (or coerced to one) or a list of factors
* drop indicates whether empty factors levels should be dropped

A common idiom is split followed by an lapply.
```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
lapply(split(x, f), mean)
```

### Splitting a Data Frame
```{r}
library(datasets)
head(airquality)
s <- split(airquality, airquality$Month)
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")],na.rm = TRUE))
```

Splitting on More than One Level
```{r}
x <- rnorm(10)
f1 <- gl(2, 5)
f2 <- gl(5, 2)
f1
f2
interaction(f1, f2)
```

Interactions can create empty levels.
```{r}
str(split(x, list(f1, f2)))
```

but these can be dropped:
```{r}
str(split(x, list(f1, f2), drop = TRUE))
```

### Debugging in R
Indications that something’s not right

* message: A generic notification/diagnostic message produced by the message function; execution of the function continues
* warning: An indication that something is wrong but not necessarily fatal; execution of the function continues; generated by the warning function
* error: An indication that a fatal problem has occurred; execution stops; produced by the stop function
* condition: A generic concept for indicating that something unexpected can occur; programmers can create their own conditions

Warning
```{r}
log(-1)
```

How do you know that something is wrong with your function?

* What was your input? How did you call the function?
* What were you expecting? Output, messages, other results?
* What did you get?
* How does what you get differ from what you were expecting?
* Were your expectations correct in the first place?
* Can you reproduce the problem (exactly)?

### Debugging Tools in R
The primary tools for debugging functions in R are

* traceback: prints out the function call stack after an error occurs; does nothing if there’s no error
* debug: flags a function for “debug” mode which allows you to step through execution of a function one line at a time
* browser: suspends the execution of a function wherever it is called and puts the function in debug mode
* trace: allows you to insert debugging code into a function a specific places
* recover: allows you to modify the error behavior so that you can browse the function call stack

These are interactive tools specifically designed to allow you to pick through a function. There’s also the more blunt technique of inserting print/cat statements in the function.

### Traceback
```{r}
rm(x)
mean(x)
traceback()
```

```{r}
lm(y ~ x)
traceback()
```

### debug
```
> debug(lm)
> lm(y ~ x)
debugging in: lm(y ~ x)
debug: {
    ret.x <- x
    ret.y <- y
    cl <- match.call()
    ...
    if (!qr)
        z$qr <- NULL 
    z
} 
Browse[2]>
...
```

### recover
```
> options(error = recover)
> read.csv("nosuchfile")
Error in file(file, "rt") : cannot open the connection
In addition: Warning message:
In file(file, "rt") :
  cannot open file ’nosuchfile’: No such file or directory

Enter a frame number, or 0 to exit

1: read.csv("nosuchfile")
2: read.table(file = file, header = header, sep = sep, quote = quote, dec =
3: file(file, "rt")

Selection:
```

### Summary

* There are three main indications of a problem/condition: message, warning, error

  + only an error is fatal
  
* When analyzing a function with a problem, make sure you can reproduce the problem, clearly state your expectations and how the output differs from your expectation

* Interactive debugging tools traceback, debug, browser, trace, and recover can be used to find problematic code in functions

* Debugging tools are not a substitute for thinking!

## Quiz - wk 3

### Question 1

Take a look at the 'iris' dataset that comes with R. The data can be loaded with the code:
```{r}
library(datasets)
data(iris)
```

A description of the dataset can be found by running
```
?iris
```

There will be an object called 'iris' in your workspace. In this dataset, what is the mean of 'Sepal.Length' for the species virginica? (Please only enter the numeric result and nothing else.)

```{r}
mean(iris[iris$Species == "virginica",]$Sepal.Length)
```

### Question 2

Continuing with the 'iris' dataset from the previous Question, what R code returns a vector of the means of the variables 'Sepal.Length', 'Sepal.Width', 'Petal.Length', and 'Petal.Width'?

```{r}
apply(iris[, 1:4], 2, mean)
```

### Question 3
Load the 'mtcars' dataset in R with the following code
```{r}
library(datasets)
data(mtcars)
```

There will be an object names 'mtcars' in your workspace. You can find some information about the dataset by running
```
?mtcars
```

How can one calculate the average miles per gallon (mpg) by number of cylinders in the car (cyl)?
```{r}
with(mtcars, tapply(mpg, cyl, mean))
```

### Question 4
Continuing with the 'mtcars' dataset from the previous Question, what is the absolute difference between the average horsepower of 4-cylinder cars and the average horsepower of 8-cylinder cars?
```{r}
mean(mtcars[mtcars$cyl == "8",]$hp) - mean(mtcars[mtcars$cyl == "4",]$hp)
```

### Question 5
If you run
```
debug(ls)
```

what happens when you next call the 'ls' function?

Execution of 'ls' will suspend at the beginning of the function and you will be in the browser.

