---
title: "R Programming"
output: html_document
---

This document contains information and code from the Coursera "R Programming" course.

# Week 1
The first week focuses on getting started and R's nuts and bolts, including: data types reading data, connections, subsetting and vectorised operations.

## Classes
Notes from the class videos

### Creating vectors
```{r}
x <- c(1,1,1)
y <- vector("numeric", length=3)
x
y
```

### Explicit Coercion
```{r}
x <- 0:5
class(x)
as.numeric(x)
as.logical(x)
as.character(x)
```

In some cases coercion does not make sense:
```{r}
x <- c("a","b","c")
as.numeric(x)
as.logical(x)
```

### Lists
Lists are a special type of vector that can contain elements of different classes.
```{r}
x <- list(1,"a",TRUE,1+4i)
x
```

### Matrices
Matrices are vectors with a dimension attribute. The dimension attribute is itself and integer vector of length 2 (nrow,ncol).
```{r}
m <- matrix(nrow=2,ncol=3)
m
dim(m)
```

Matrices are constructed column-wise, e.g.:
```{r}
m <- matrix(1:6, nrow=2,ncol=3)
m
```

Matrices may even be created directly from a vector by adding a dimension attribute, e.g.:
```{r}
m <- 1:10
m
dim(m) <- c(2,5)
m
```

# cbind-ing and rbind-ing
Matrices can be created by column-binding or row-binding with ```cbind()``` and ```rbind()```:
```{r}
x <-1:3
y <- 10:12
cbind(x,y)
rbind(x,y)
```

### Factors
Factors are used to represent categorical data. They can be unordered or ordered. You can think of a factor as an integer vector where each integer has a label.

* Factors are treated specially by modelling functions like ```lm()``` and ```gm()```.
* Using factors with labels is better than using integers because factors are self-describing; having a variable that has values "Male" and "Female" is better than a variable that has values 1 and 2.

```{r}
x <- factor(c("yes", "yes", "no", "yes", "no"))
x
table(x)
unclass(x)
```

The order of the levels can be set using the ```levels``` argument to ```factor()```. This can be important in linear modelling because the first level is used as the baseline level.

```{r}
x <- factor(c("yes", "yes", "no", "yes", "no"),
            levels=c("yes","no"))
x
```

### Missing values

Missing values are denoted by either NA or NaN for undefined mathematical operations.

You can check for NA using ```is.na()```:

```{r}
x <- c(1, 2, NA, 4, 5)
is.na(x)
```

### Data Frames

Data frames are used to store tabular data

* They are represented as a special type of list where every element of the list has to have the same length
* Each element of the list can be thought of as a column and the length of each element of the list is the number of rows.
* Unlike matrices, data frames can store different classes of objects in each column (just like lists).
* Data frames also have a special attribute called row.names
* Data frames are usually created by calling ```read.table()``` or ```read.csv()```.
* Can be converted to a matrix by calling ```data.matrix()```.

Besides the above, we can also use the ```data.frame()``` function to create them:
```{r}
x <- data.frame(foo = 1:4, bar = c(T,T,F,F))
x
nrow(x)
```

### Names
All R objects (not just data frames) can have names. This is very useful for writing readable code and self-describing objects.

```{r}
x <- 1:3
names(x) <- c("foo", "bar", "norf")
x
names(x)
```

List can also be named:
```{r}
x <- list(a=1,b=2,c=3)
x
```

as can matrices...
```{r}
m <- matrix(1:4,nrow=2,ncol=2)
dimnames(m) <- list(c("a","b"),c("d","e"))
m
```

### Reading large tables

With relatively large data sets, there are a few "tricks" that can make your life easier and prevent R from chocking when reading data:

* Make a rough calculation of the memory required to store your data set. If the data set is larger than the amount of RAM on your computer then you can probably stop there.
* Set ```comment.char=""``` if there are no commented lines in your file.
* Use the ```colClasses``` argument. Specifying this option instead of using the default can make ```read.table()``` run MUCH faster, often twice as fast. In order 
* Set ```nrows```. This doesn't make R run faster but it helps with memory usage. A mild overestimate is okay. You can use the Unix tool ```wc``` to calculate the number of lines in a file.

### Textual formats

* **Dumping** and **dputing** are useful because the resulting textual format is edit-able, and in the case of corruption, potentially recoverable.
* Unlike writing out a table or csv file, ```dump``` and ```dput``` preserve the metadata (sacrificing some readability) so that another user doesn't have to specify it all over again.
* Textual formats can work much better with version control programs.
* They can be longer lived; if there is corruption somewhere in the file, it can be easier to fix the problem.
* Textual formats adhere to the "Unix philosophy".
* Downside: The format is not very space=efficient.

You can deparse an R object with ```dput``` and read it back in with ```dget```:
```
y <- data.frame(a=1,b="a")
dput(y, "file.R")
new.y <- dget("y.R")
```

Multiple r objects can be deparsed using the dump function and read back in using source.
```
x <- "foo"
y <- data.frame(a=1,b="a")
dump(c("x","y"), "file.R")
rm(x,y)
source("file.R")
```

### Connections: Interfaces to the outside world
Data are read in using connection interfaces. Connections can be made to files or to other more exotic things.

* ```file```, opens a connection to a file.
* ```gzfile```, opens a connection to a file compressed with gzip.
* ```bzfile```, opens a connections to a file compressed with bzip2.
* ```url```, opens a connection to a webpage.

In general, connections are powerful tools that let you navigate files or other external objects. In conjunction with the readlines function, connections may be used to read webpages:

```{r}
con <- url("http://www.jhsph.edu", "r")
x <- readLines(con)
head(x)
```

### Subsetting: Basics

There are a number of operators that can be used to extract subsets of R objects:

* ```[``` always returns an object of the same class as the original; can be used to select more than one element.
* ```[[``` is used to extract elements of a list or data frame; it can only be used to extract a single element and the class of the returned object will not necessarily be a list or data frame.
* ```$``` is used to extract elements of a list or data frame by name; semantics are similar to that of ```[[```.

### Subsetting: Vectors

```{r}
x <- c("a", "b", "c", "d", "a")
x[1]
x[1:3]
x[x>"a"]
```

### Subsetting: Lists

Lists may be subsetted by any of the three methods discussed about but each will provide a different result. 

```{r}
x <- list(foo=1:4, bar=0.6)
x[1]
x[[1]]
x$bar
x[["bar"]]
x["bar"]
```

To extract multiple elements from a list, you must use the single bracket operator:

```{r}
x <- list(foo=1:4, bar=0.6, baz = "hello")
x[c(1,3)]
```

The nice thing about the double bracket operator is that it can be used with computed indices; ```$``` can only be used with literal names:

```{r}
x <- list(foo=1:4, bar=0.6, baz = "hello")
name <- "foo"
x[[name]]
x$name
```

### Subsetting: Nested elements of a list

```{r}
x <- list(a=list(10,12,14), b=c(3.14,2.81))
x[[c(1,3)]]
x[[1]][[3]]
```

### Subsetting: Matrices

Matrices may be subsetted in the usual way with (i,j) type indices, as well ass missing indices:

```{r}
x <- matrix(1:6,2,3)
x[1,2]
x[1,]
x[,2]
```

By default, when a single element of a matrix is retrieved, it is returned as a vector of length 1 rather than a 1 x 1 matrix. This behavior can be turned off by setting ```drop=FALSE```.

### Subsetting: Removing missing values

A common task is the removal of missing values.

```{r}
x <- c(1,2,NA,4,NA,6)
bad <- is.na(x)
x[!bad]
```

If there are multiple things from which you want to create a subset with no missing values, then ```complete.cases()``` is your man:

```{r}
x <- c(1,2,NA,4,NA,6)
y <- c("a","b",NA,NA,"e","f")
good<-complete.cases(x,y)
x[good]
y[good]
```

Complete cases can also be used to remove missing values from data frames in the same manner.

### Vectorised operations

Many operations in R are vectorized making code more efficient, concise and easier to read.

```{r}
x <- 1:4; y <- 6:9
x+y
x>2
```

### Vectorised matrix operations

Element wise multiplication:
```{r}
x <- matrix(1:4,2,2); y <- matrix(rep(10,4),2,2)
x*y
```

True matrix multiplication:
Element wise multiplication:
```{r}
x <- matrix(1:4,2,2); y <- matrix(rep(10,4),2,2)
x%*%y
```

# Week 1
The second week jumps into programming with R.

## Classes
Notes from the class videos

### Control structures - If-else
Allows you to test logical conditions and let R do things based on whether of not that condition is true.
```
if(<condition>) {
  # do something
} else {
  # do something else
}

if(<condition1>) {
  # do something
} else if(<condition2> {
  # do something different
} else {
  # do something else
}
```
### Control structures - For Loop
for loops take an iterator variable and assign it successive values from a sequence or vector. For loops are most commonly used for iteration over the elements of an object:
```
for(i in 1:10) {
  print(i)
}
```

for loops can also be nested but things can get hard to read very quickly:
```
x<- matrix(1:6,2,3)
for(i in seq_len(nrow(x))) {
  for(j in seq_len(ncol(x))) {
    print[x[i,j]]
  }
}
```

### Control structures - While Loop
While loops begin by testing a condition. If it is true, then they execute the loop body. Once the loop body is executed, the condition is tested again.
```
count <- 0
while(count<10) {
  print(count)
  count<-count+1
}
```

If not written with care, while loops may result in infinite loops. There can be more than one condition in the test, where conditions are evaluated from left to right:
```
z <- 5
while(z >= 3 && z <=10) {
  print(z)
  coin <- rbinom(1, 1, 0.5)
  
  if(coin == 1) { ## random walk
    z <- z+1
  } else {
    z <- z-1
  }
}
```

### Control structures - Repeat
Repeat is a construct that initiates and infinite loop; these are not commonly used in statistical applications but they do have their uses. The only way to exit a repeat loop is to call ```break```
```
x0 <- 1
tol <-1e-8

repeat {
  x1 <- computeEstimate()
  
  if (abs(x1-x0) < tol) {
    break
  } else {
    x0 <- x1
  }
}
```

Repeat loops can be dangerous when there is no guarantee that they will stop. It is usually better to set a hard number of iterations (e.g. using a for loop) and then report whether convergence was achieved or not.

### Control structures - Next
```next``` is used to skip an iteration of a loop
```
for(i in 1:100) {
  if(i <=20) {
    ## skip the first 20 iterations
    next
  }
  ### Do something here
}
```

### Writing functions in R
In R, the function returns whatever the last expression was.
```
aboveX <- function(x, threshold) {
  use <- x>threshold
  x[use]
}
```

R functions also allow default arguments, as below:
```
aboveX <- function(x, threshold=10) {
  use <- x>threshold
  x[use]
}
```

Most function will revolve around data structures and the following code creates a function calculates the mean of each column in a dataframe or matrix.
```
columnMean <- function(y, removeNA = TRUE) {
  nc <- ncol(y)
  means <- numeric(nc)
  for(i in 1:nc) {
    means[i] <- mean(y[,i],na.rm=removeNA)
  }
  means
}
```

### Arguement Matching
R function arguments can be matched positionally or by name. So the following calls to sd are all equivalent:
```
sd(mydata)
sd(x=mydata)
sd(x=mydata, na.rm=FALSE)
sd(na.rm=FALSE, x=mydata)
sd(na.rm=FALSE, mydata)
```

Even though it is legal, I don't recommend messing around with the order of the arguments too much, it can lead to considerable confusion.

You can mix positional matching with matching by name. When an argument is matched by name, it is "taken out" of the argument list and the remaining unnamed arguments are matched in the order that they are listed in the function definition.
```{r}
args(lm)
```

### Lazy Evaluation
Arguments to functions are evaluated lazily, so they are evaluated only as needed.
```
f <- function(a,b) {
 a^2
}
f(2)
```

This function never actually uses the argument ```b```, so calling ```f(2)``` will not produce an error because the 2 gets possitionally matched to ```a```.

### The "..." Argument
The ```...``` argument indicates a variable number of arguments that are usually passed on to other functions.

* ```...``` is often used when extending another function and you don't want to copy the entire argument list of the original function.
```
myplot <-function(x, y, type="l", ...) {
  plot(x, y, type=type, ...)
}
```
* Generic functions use ```...``` so that extra arguments can be passed to methods (more on this later).
```{r}
mean
```

The ```...``` argument is also necessary when the number of arguments passed to the function cannot be known in advance
```{r}
args(paste)
```

One catch with the ```...``` argument is that any arguments that appear after it on the argument list must be names explicitly and cannot be partially matched.

### Symbol binding
When R tries to bind a value to a symbol, it searches through a series of ```environments``` to find the appropriate value. When you are working on the command line and need to retrieve the value of an R object, the order is roughly:

1. Search the global environment for a symbol name matching the one requested.
2. Search the namespaces of each of the packages n the searchlist.

The searchlist can be found using the ```search``` function:
```{r}
search()
```
 * The global environement or the user's workspace is always the first elemenet of the search list and the base package is always the last.
 * The order of the packages on the search list matters
 * User's can configure which packages get loaded on startup so you cannot assume that there will be a set list of packages available.
 * When a user loads a package with ```library``` the namespace of that package gets put in position 2 of the search list.
 * Note that R has separate namespaces for functions and non-functions so it's possible to have an object named c and a fucntion names c.

### Scoping rules
The scoping rules for R are the main feature that make it sifferent from the original S language.

* The scoping rules determine how a value is associated with a free variable in a function
* R uses lexical scoping or static scoping. A common alternative is dynamic scoping.
* Related to the scoping rules is how R uses the search list to bind a value to a symbol.
* Lexical scoping turns out to be particularly useful for simplifying statistical computations.

Consider the following function:
```
f <- function(x, y) {
  x^2 + y / z
}
```

This function has two formal arguments x and y. In the body of the function there is another symbol ```z```. In this case ```z``` is called a free variable. The scoping rules of the language determine how values are assigned to the free variables. Free variables are not formal arguments and are not local variables.

### Lexical scoping
Lexical scoping means that:

> the values of free variables are searched for in the environment in which the function was defined.

What is an environment?

* A collection of (symbol, value) pairs, i.e. x is a symbol and 3.14 might be its value.
* Every environment has a parent environment; it is possible for an environment to have multiple "children".
* The only environment without a parent is the empty environment.
* A function + an environment = a closure or function closure.

So what hapens when searching for the value for a free variable:

* If the value of a symbol is not found in the environment in which a function was defined, then the search is continued in the parent environment.
* The search environment continues down the sequence of parent environments until we hit the top-level environement; this is usually the global environment or the namespace of a package.
* After the top-level environment, the search continues down the search list until we hit the empty environment. If the value for a gien symbol cannot be found by this point then and error is thrown.

Why does all of this matter?

* Typicaly, a function is defined in the global environment, so that the values of the free variables are just found in the user's workspace.
* This behaviour is logical for most people and is usually the "right thing" to do.
* However, in R you can have functions defined inside other functions
  ** Languages like C don't let you do this
* Now things get interesting - In this case the environment in which the function is defined is the body of another function!

```{r}
make.power <- function(n) {
  pow <- function(x) {
    x^n
  }
  pow
}
```

This function returns another function as its value.

```{r}
cube <-make.power(3)
square <- make.power(2)
cube(3)
square(3)
```

### Exploring a function closure
What's in a function's environment?
```{r}
ls(environment(cube))
get("n", environment(cube))
```

### Consequences of Lexical Scoping

* In R, all objects must be stored in memory
* All functions must carry a pointer to their respective defining environments, which could be anywhere.
* In S-PLUS, free variables are always looked up in the global workspace, so everything can be stored on the disk because the defining environment of all the functions are the same.

### Coding Standards for R

1. Always use text files / text editor
2. Indent your code
3. Limit the width of your code (80 columns?)
4. Limit the length of individual functions

### Indenting

* Indenting improves readability
* Fixing line length (80 columns) prevents lots of nesting and very long functions
* Suggested: Indents of 4 spaces at minimum; 8 spaces ideal

### Dates and Times in R
R has developed a special representation of dates and times

* Dates are represented by the Date class
* Times are represented by the POSIXct or the POSIXlt class
* Dates are stored internally as the number of days since 1970-01-01
* Tmes are stored internally as the number of seconds since 1970-01-01

### Dates in R
Dates are represented by the Date class and can be coerced from a character string using the ```as.Date()``` function.
```{r}
x <- as.Date("1970-01-01")
x
unclass(x)
unclass(as.Date("1970-01-02"))
```

### Times in R
Times are represented using the POSIXct or the POSIXlt class

* POSIXct is just a very large integer under the hood; it use a useful class when you want to store times in something like a data frame.
* POSIXlt is a list underneath and it stores a bunch of other useful information like the day of the week, day of the year, month, day of the month

There are a number of generic functions that work on dates and times

* weekdays: give the day of the week
* months: give the month name
* quarters: give the quarter number (“Q1”, “Q2”, “Q3”, or “Q4”)

Times can be coerced from a character string using the ```as.POSIXlt``` or ```as.POSIXct``` function.
```{r}
x <- Sys.time()
x
p <- as.POSIXlt(x)
names(unclass(p))
p$sec
```

You can also use the POSIXct format.
```{r}
x <- Sys.time()
x  ## Already in ‘POSIXct’ format
p <- as.POSIXlt(x)
p$sec
```

Finally, there is the strptime function in case your dates are written in a different format
```{r}
datestring <- "January 10, 2012 10:40"
x <- strptime(datestring, "%B %d, %Y %H:%M")
x
class(x)
```

I can never remember the formatting strings. Check ?strptime for details.

### Operations on Dates and Times
You can use mathematical operations on dates and times. Well, really just + and -. You can do comparisons too (i.e. ==, <=)
```{r}
x <- as.Date("2012-01-01")
y <- strptime("9 Jan 2011 11:34:21", "%d %b %Y %H:%M:%S") 
x <- as.POSIXlt(x) 
x-y
```

Even keeps track of leap years, leap seconds, daylight savings, and time zones.
```{r}
x <- as.Date("2012-03-01") 
y <- as.Date("2012-02-28") 
x-y
x <- as.POSIXct("2012-10-25 01:00:00")
y <- as.POSIXct("2012-10-25 06:00:00", tz = "GMT") 
y-x
```

### Summary

* Dates and times have special classes in R that allow for numerical and statistical calculations
* Dates use the Date class
* Times use the POSIXct and POSIXlt class
* Character strings can be coerced to Date/Time classes using the strptime function or the ```as.Date```, ```as.POSIXlt```, or ```as.POSIXct```.





